# manual

shell 的配置文件中添加，方便调试
```bash
alias MQGDB="make CPUS=1 qemu-gdb"
alias RGDB="riscv64-unknown-elf-gdb"
```

# 调度算法移植

## 7.1 原始xv6调度机制分析

### 7.1.1 进程控制块与调度状态

任何操作系统运行的进程数量都可能超过计算机的CPU数量，因此需要制定一个方案，在各进程之间分时共享CPU。原始xv6采用简单的**轮转调度算法（Round Robin）**，通过将进程复用到硬件CPU上，给每个进程提供它有自己的虚拟CPU的假象。

#### 进程状态定义（kernel/proc.h）
```c
enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
```

原始xv6的进程控制块`struct proc`中仅包含基本的调度信息：
```c
struct proc {
  struct spinlock lock;        // 进程锁，保护进程状态和上下文
  enum procstate state;        // 进程状态
  // ... 其他基本字段
  // 注意：缺少优先级、统计信息等调度相关字段
};
```

#### 调度不变量（Scheduling Invariants）
xv6调度器维护以下关键不变量：
1. 如果一个进程正在运行（`p->state == RUNNING`），那么定时中断导致的`yield()`必须能够安全地让它让出CPU
2. 如果一个进程是可运行的（`p->state == RUNNABLE`），那么对于空闲的CPU调度器来说，运行它必须是安全的
3. 这些不变量在持有`p->lock`时得到保护

### 7.1.2 调度器实现分析

#### 调度器核心循环（kernel/proc.c）
```c
void scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu();
  
  c->proc = 0;
  for(;;) {
    // 允许中断
    intr_on();
    
    // 遍历进程表寻找可运行进程
    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state == RUNNABLE) {
        // 切换到找到的进程
        p->state = RUNNING;
        c->proc = p;
        swtch(&c->context, &p->context);
        
        // 进程返回后的清理
        c->proc = 0;
      }
      release(&p->lock);
    }
  }
}
```

#### 上下文切换机制
xv6的调度通过`swtch()`函数实现上下文切换：
1. **用户-内核切换**：通过系统调用或中断进入内核
2. **内核-调度器切换**：`sched()`调用`swtch()`切换到调度器线程
3. **调度器-内核切换**：调度器选择新进程后切换到其内核线程
4. **内核-用户切换**：通过`usertrapret()`返回用户空间

```c
// 进程让出CPU的典型路径
void yield(void) {
  acquire(&p->lock);
  p->state = RUNNABLE;
  sched();          // 调用swtch切换到调度器
  release(&p->lock);
}

void sched(void) {
  // 检查不变量：必须持有p->lock，中断必须禁用
  if(!holding(&p->lock)) panic("sched p->lock");
  if(mycpu()->noff != 1) panic("sched locks");
  if(p->state == RUNNING) panic("sched running");
  if(intr_get()) panic("sched interruptible");
  
  swtch(&p->context, &mycpu()->context); // 切换到调度器
}
```

#### 时钟中断处理（kernel/trap.c）
```c
void clockintr()
{
  acquire(&tickslock);
  ticks++;
  wakeup(&ticks);  // 唤醒等待时间事件的进程
  release(&tickslock);
  
  // 注意：原始xv6没有进程统计信息更新
  // 设置下一个定时器中断（约0.1秒）
  w_stimecmp(r_time() + 1000000);
}
```

### 7.1.3 原始调度算法局限性

如xv6-book第7.9节所述，原始调度器实现简单但存在以下问题：

1. **算法单一性**：只支持轮转调度，缺乏现代操作系统所需的多样化调度策略
2. **无优先级支持**：所有进程平等对待，无法区分系统进程和用户进程
3. **缺乏统计监控**：无法收集进程运行时间、等待时间等关键性能指标
4. **静态时间片**：固定时间片长度，无法适应不同负载场景
5. **公平性问题**：长进程可能阻塞短进程，影响系统响应时间

## 7.2 调度算法移植：架构与设计

### 7.2.1 移植目标与挑战

本毕设项目将基于x86架构的lab-scheduling项目的调度算法改进移植到RISC-V架构的xv6操作系统中。移植面临以下挑战：

1. **架构差异**：x86使用栈传递系统调用参数，RISC-V使用寄存器
2. **内存管理**：安全访问用户空间指针，避免页面错误
3. **并发控制**：调度器锁管理的正确性
4. **性能优化**：减少调度开销的同时保持功能完整

### 7.2.2 进程控制块扩展

为支持多种调度算法，需要扩展进程控制块结构：

```c
// kernel/proc.h - 扩展后的proc结构体
struct proc {
  // ... 原有字段
  
  // ========== 调度算法扩展字段 ==========
  // 优先级调度相关
  int priority;          // 进程优先级（1-20，1为最高）
  
  // 彩票调度相关  
  int tickets;           // 彩票数（默认值：DEFAULT_TICKETS）
  
  // FCFS调度相关
  int ctime;             // 进程创建时间（时钟滴答数）
  
  // 调度统计字段（用于性能分析和监控）
  int retime;            // 就绪时间（READY状态时间）
  int rutime;            // 运行时间（RUNNING状态时间）
  int stime;             // 睡眠时间（SLEEPING状态时间）
  
  // ... 其他原有字段
};
```

#### 字段初始化（kernel/proc.c）
```c
static struct proc* allocproc(void) {
  // ... 原有代码
  
  // 条件编译初始化调度字段
  #ifdef PRIORITY
    p->priority = 10;  // 默认中等优先级
  #else
  #ifdef SML
    p->priority = 2;   // 默认中级优先级（多级反馈队列）
  #endif
  #endif
  
  // 记录创建时间（用于FCFS调度）
  p->ctime = ticks;
  
  // 初始化统计信息
  p->retime = 0;
  p->rutime = 0;
  p->stime = 0;
  
  // 初始化彩票数（用于彩票调度）
  p->tickets = DEFAULT_TICKETS;
  
  // ... 后续代码
}
```

### 7.2.3 条件编译架构设计

为实现多种调度算法的灵活选择，采用条件编译架构：

```makefile
# Makefile配置
ifdef SCHEDFLAG
CFLAGS += -D$(SCHEDFLAG)
endif

# 使用示例
# make qemu SCHEDFLAG=DEFAULT    # 默认轮转调度
# make qemu SCHEDFLAG=PRIORITY   # 优先级调度
# make qemu SCHEDFLAG=FCFS       # 先来先服务
# make qemu SCHEDFLAG=LOTTERY    # 彩票调度
# make qemu SCHEDFLAG=SML        # 多级反馈队列
```

## 7.3 移植调度算法实现分析

### 7.3.1 调度器框架重构

移植后的`scheduler()`函数采用条件编译支持多种算法：

```c
void scheduler(void) {
  struct proc *p;
  struct cpu *c = mycpu();
  
  c->proc = 0;
  
  for(;;) {
    intr_on();
    
    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      
      // ========== 条件编译调度选择 ==========
      #ifdef DEFAULT
        // 默认轮转调度（保持与原始xv6兼容）
        if(p->state != RUNNABLE) {
          release(&p->lock);
          continue;
        }
        // p保持不变，使用当前遍历到的进程
      
      #elif defined(PRIORITY)
        // 优先级调度算法
        if(p->state != RUNNABLE) {
          release(&p->lock);
          continue;
        }
        p = find_highest_priority_process();
      
      #elif defined(FCFS)
        // 先来先服务调度算法
        if(p->state != RUNNABLE) {
          release(&p->lock);
          continue;
        }
        p = find_earliest_created_process();
      
      #elif defined(LOTTERY)
        // 彩票调度算法
        if(p->state != RUNNABLE) {
          release(&p->lock);
          continue;
        }
        p = select_process_by_lottery();
      
      #elif defined(SML)
        // 多级反馈队列调度算法
        if(p->state != RUNNABLE) {
          release(&p->lock);
          continue;
        }
        p = select_process_from_multilevel_queue();
      
      #endif
      // ========== 条件编译结束 ==========
      
      // 公共的进程运行逻辑（保持原有不变量）
      if(p != 0 && p->state == RUNNABLE) {
        // 设置进程状态和CPU当前进程
        p->state = RUNNING;
        c->proc = p;
        
        // 执行上下文切换
        swtch(&c->context, &p->context);
        
        // 进程返回后的清理
        c->proc = 0;
      }
      
      release(&p->lock);
    }
  }
}
```

### 7.3.2 优先级调度算法（PRIORITY）

#### 算法理论
优先级调度算法总是选择优先级最高的可运行进程。优先级数值越小表示优先级越高（1为最高），相同优先级时按轮转调度处理。

#### 核心实现
```c
#ifdef PRIORITY
// 寻找优先级最高的可运行进程
struct proc* find_highest_priority_process(void) {
  struct proc *p, *highest = 0;
  
  // 遍历所有进程，保持锁的正确性
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    
    if(p->state == RUNNABLE) {
      if(highest == 0 || p->priority < highest->priority) {
        // 找到更高优先级的进程
        if(highest != 0)
          release(&highest->lock); // 释放之前highest的锁
        highest = p;
        // 保持highest的锁，不释放
      } else {
        release(&p->lock);
      }
    } else {
      release(&p->lock);
    }
  }
  
  return highest; // 返回时仍然持有该进程的锁
}
#endif
```

#### 算法特点与问题
1. **实时性**：高优先级进程能快速响应，适合实时系统
2. **饥饿问题**：低优先级进程可能永远无法运行（优先级反转）
3. **锁管理**：需要仔细处理进程锁，避免死锁和竞争条件

### 7.3.3 先来先服务调度算法（FCFS）

#### 算法理论
FCFS选择创建时间最早的进程，是非抢占式调度算法。该算法忽略系统进程（pid <= 1），保证任务执行顺序。

#### 核心实现
```c
#ifdef FCFS
// 寻找创建时间最早的进程
struct proc* find_earliest_created_process(void) {
  struct proc *p, *earliest = 0;
  
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    
    // 忽略init和shell等系统进程
    if(p->state == RUNNABLE && p->pid > 1) {
      if(earliest == 0) {
        earliest = p;
      } else if(p->ctime < earliest->ctime) {
        // 找到更早创建的进程
        release(&earliest->lock);
        earliest = p;
      } else {
        release(&p->lock);
      }
    } else {
      release(&p->lock);
    }
  }
  
  return earliest;
}
#endif
```

#### 算法特点
1. **简单性**：实现简单，调度开销小
2. ** convoy效应**：长进程阻塞短进程，影响系统响应时间
3. **确定性**：进程执行顺序可预测，适合批处理系统

### 7.3.4 彩票调度算法（LOTTERY）

#### 算法理论
彩票调度为每个进程分配一定数量的彩票，根据总彩票数随机选择进程。彩票数越多，被选中的概率越大，CPU时间分配比例与彩票数成正比。

#### 核心实现
```c
#ifdef LOTTERY
// 计算所有可运行进程的总彩票数
int total_tickets(void) {
  struct proc *p;
  int total = 0;
  
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state == RUNNABLE) {
      total += p->tickets;
    }
    release(&p->lock);
  }
  
  return total;
}

// 伪随机数生成器（线性反馈移位寄存器变体）
int random(int max) {
  static unsigned long seed = 123456789;
  seed = (seed * 1103515245 + 12345) & 0x7fffffff;
  return seed % max;
}

// 根据彩票随机选择进程
struct proc* select_process_by_lottery(void) {
  int total = total_tickets();
  if(total == 0) return 0;
  
  int winner = random(total);
  struct proc *p;
  
  // 遍历进程，减去彩票数，找到中奖进程
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state == RUNNABLE) {
      winner -= p->tickets;
      if(winner < 0) {
        // 找到中奖进程，保持锁并返回
        return p;
      }
    }
    release(&p->lock);
  }
  
  return 0;
}
#endif
```

#### 算法特点
1. **公平性**：CPU时间分配与彩票数成正比，确保公平性
2. **随机性**：使用伪随机数避免确定性调度
3. **灵活性**：可通过调整彩票数控制进程优先级
4. **无饥饿**：所有进程都有获得CPU时间的机会

### 7.3.5 多级反馈队列调度算法（SML）

#### 算法理论
多级反馈队列（SML）维护三级优先级队列：高、中、低。新进程进入中级队列，时间片用完后降低优先级，高优先级队列空时才调度低优先级队列。

#### 核心实现
```c
#ifdef SML
// 三级队列索引（静态变量，每个CPU独立）
static int queue_index[3] = {0, 0, 0};

// 从指定优先级队列查找进程
struct proc* find_process_in_queue(int queue_level) {
  int i;
  struct proc *p;
  
  // 从当前索引开始循环查找
  for(i = 0; i < NPROC; i++) {
    int idx = (queue_index[queue_level] + i) % NPROC;
    p = &proc[idx];
    
    acquire(&p->lock);
    if(p->state == RUNNABLE && p->priority == queue_level + 1) {
      // 更新队列索引，保持锁并返回
      queue_index[queue_level] = (idx + 1) % NPROC;
      return p;
    }
    release(&p->lock);
  }
  
  return 0;
}

// 多级队列选择进程（从高到低优先级查找）
struct proc* select_process_from_multilevel_queue(void) {
  struct proc *p = 0;
  
  // 从高优先级队列开始查找
  for(int level = 0; level < 3; level++) {
    p = find_process_in_queue(level);
    if(p != 0) {
      // 检查时间片用完，可能需要降低优先级
      // 注意：实际的时间片检查在时钟中断中处理
      return p;
    }
  }
  
  return 0;
}
#endif
```

#### 算法特点
1. **响应性**：交互式进程能快速响应
2. **公平性**：防止CPU密集型进程独占CPU
3. **自适应性**：根据进程行为动态调整优先级
4. **负载均衡**：平衡响应时间和吞吐量需求

## 7.4 统计功能与系统调用扩展

### 7.4.1 统计信息收集机制

如xv6-book第7.1节所述，原始xv6缺乏进程统计信息收集功能。移植后添加了完整的统计收集机制：

```c
// 每个时钟中断更新统计信息（kernel/trap.c）
void updatestatistics(void) {
  struct proc *p;
  
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    
    // 根据进程状态更新相应统计字段
    switch(p->state) {
      case SLEEPING:
        p->stime++;    // 睡眠时间增加
        break;
      case RUNNABLE:
        p->retime++;   // 就绪时间增加
        break;
      case RUNNING:
        p->rutime++;   // 运行时间增加
        break;
      default:
        // 其他状态（UNUSED, USED, ZOMBIE）不统计
        break;
    }
    
    release(&p->lock);
  }
}

// 在clockintr()中调用统计更新
void clockintr() {
  acquire(&tickslock);
  ticks++;
  wakeup(&ticks);
  release(&tickslock);
  
  // 新增：更新调度统计信息
  updatestatistics();
  
  w_stimecmp(r_time() + 1000000);
}
```

### 7.4.2 wait2系统调用实现

`wait2`系统调用扩展了原始的`wait`功能，增加了统计信息返回：

```c
// kernel/proc.c
int wait2(uint64 retime_addr, uint64 rutime_addr, uint64 stime_addr) {
  struct proc *p;
  int havekids, pid;
  struct proc *curproc = myproc();
  
  acquire(&wait_lock);
  
  for(;;) {
    havekids = 0;
    
    // 查找僵尸子进程
    for(p = proc; p < &proc[NPROC]; p++) {
      if(p->parent != curproc)
        continue;
      
      havekids = 1;
      acquire(&p->lock);
      
      if(p->state == ZOMBIE) {
        pid = p->pid;
        
        // 安全复制统计信息到用户空间
        if(retime_addr != 0) {
          if(copyout(curproc->pagetable, retime_addr, 
                     (char *)&p->retime, sizeof(p->retime)) < 0) {
            release(&p->lock);
            release(&wait_lock);
            return -1;
          }
        }
        
        if(rutime_addr != 0) {
          if(copyout(curproc->pagetable, rutime_addr,
                     (char *)&p->rutime, sizeof(p->rutime)) < 0) {
            release(&p->lock);
            release(&wait_lock);
            return -1;
          }
        }
        
        if(stime_addr != 0) {
          if(copyout(curproc->pagetable, stime_addr,
                     (char *)&p->stime, sizeof(p->stime)) < 0) {
            release(&p->lock);
            release(&wait_lock);
            return -1;
          }
        }
        
        // 释放子进程资源
        freeproc(p);
        release(&p->lock);
        release(&wait_lock);
        return pid;
      }
      release(&p->lock);
    }
    
    // 没有子进程或进程被杀死
    if(!havekids || killed(curproc)) {
      release(&wait_lock);
      return -1;
    }
    
    // 等待子进程退出（保持wait_lock）
    sleep(curproc, &wait_lock);
  }
}
```

### 7.4.3 新增系统调用接口

移植添加了6个新的系统调用以支持调度管理：

```c
// 用户空间接口（user/user.h）
int chpr(int pid, int priority);          // 修改进程优先级
int chtickets(int pid, int tickets);      // 修改进程彩票数
int wait2(int *retime, int *rutime, int *stime); // 等待并获取统计
int getppid(void);                        // 获取父进程ID
int getptable(int size, char *buf);       // 获取进程表信息
int yield(void);                          // 主动让出CPU
```

#### 系统调用号定义（kernel/syscall.h）
```c
#define SYS_chpr      23
#define SYS_chtickets 24
#define SYS_wait2     25
#define SYS_getppid   26
#define SYS_getptable 27
#define SYS_yield     28
```

#### 系统调用分发（kernel/syscall.c）
```c
extern uint64 sys_chpr(void);
extern uint64 sys_chtickets(void);
extern uint64 sys_wait2(void);
extern uint64 sys_getppid(void);
extern uint64 sys_getptable(void);
extern uint64 sys_yield(void);

static uint64 (*syscalls[])(void) = {
  // ... 原有系统调用
  [SYS_chpr]      sys_chpr,
  [SYS_chtickets] sys_chtickets,
  [SYS_wait2]     sys_wait2,
  [SYS_getppid]   sys_getppid,
  [SYS_getptable] sys_getptable,
  [SYS_yield]     sys_yield,
};
```

### 7.4.4 系统调用实现示例

#### chpr系统调用实现
```c
// kernel/sysproc.c
uint64 sys_chpr(void) {
  int pid, priority;
  
  // 获取参数（RISC-V使用寄存器传递）
  if(argint(0, &pid) < 0 || argint(1, &priority) < 0)
    return -1;
  
  // 参数验证
  if(priority < 1 || priority > 20)
    return -1;
  
  return chpr(pid, priority);
}

// kernel/proc.c
int chpr(int pid, int priority) {
  struct proc *p;
  
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->pid == pid) {
      p->priority = priority;
      release(&p->lock);
      return pid;
    }
    release(&p->lock);
  }
  
  return -1; // 进程未找到
}
```

#### yield系统调用实现
```c
// kernel/sysproc.c
uint64 sys_yield(void) {
  yield();
  return 0;
}

// kernel/proc.c
void yield(void) {
  struct proc *p = myproc();
  acquire(&p->lock);
  p->state = RUNNABLE;
  sched();  // 调用swtch切换到调度器
  release(&p->lock);
}
```

## 7.5 移植问题与解决方案深度分析

### 7.5.1 架构差异问题

如xv6-book第4章所述，x86和RISC-V在系统调用实现上存在显著差异：

| 特性 | x86架构 | RISC-V架构 | 解决方案 |
|------|---------|------------|----------|
| 参数传递 | 通过栈传递 | 通过寄存器a0-a5传递 | 使用argint()/argaddr() |
| 系统调用号 | 通过eax传递 | 通过a7传递 | 调整系统调用分发 |
| 返回地址 | 通过栈保存 | 通过ra寄存器保存 | 保持trapframe兼容 |

#### 具体代码调整示例
```c
// x86风格（原lab-scheduling）
int sys_wait2(void) {
  int *retime, *rutime, *stime;
  
  // 直接使用argptr（x86特有）
  if(argptr(0, (void*)&retime, sizeof(*retime)) < 0 ||
     argptr(1, (void*)&rutime, sizeof(*rutime)) < 0 ||
     argptr(2, (void*)&stime, sizeof(*stime)) < 0)
    return -1;
  
  return wait2(retime, rutime, stime);
}

// RISC-V风格（移植后）
uint64 sys_wait2(void) {
  uint64 retime_addr, rutime_addr, stime_addr;
  
  // 使用argaddr获取用户空间地址
  if(argaddr(0, &retime_addr) < 0 ||
     argaddr(1, &rutime_addr) < 0 ||
     argaddr(2, &stime_addr) < 0)
    return -1;
  
  return wait2(retime_addr, rutime_addr, stime_addr);
}
```

### 7.5.2 内存管理问题

#### 用户空间指针安全访问
**问题**：直接解引用用户空间指针导致页面错误（scause=0xf）
```c
// 错误示例（导致panic）
*retime = p->retime; // 可能触发页面错误
```

**解决方案**：使用copyout安全复制
```c
// 正确实现
if(copyout(curproc->pagetable, retime_addr, 
           (char *)&p->retime, sizeof(p->retime)) < 0) {
  // 错误处理
}
```

#### 页表处理机制
```c
// 获取当前进程页表
struct proc *curproc = myproc();
pagetable_t pagetable = curproc->pagetable;

// 安全复制数据到用户空间
int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {
  // 内核实现，确保地址在用户空间有效
  // 处理页表边界和权限检查
}
```

### 7.5.3 锁管理问题

#### 调度器锁管理缺陷
**问题**：在PRIORITY算法中，highest指向的进程锁状态不一致
```c
// 问题代码（原lab-scheduling实现）
for(p1 = proc; p1 < &proc[NPROC]; p1++) {
  acquire(&p1->lock);
  if((p1->state == RUNNABLE) && (highP->priority > p1->priority))
    highP = p1;  // highP现在指向p1，但p1的锁在循环中会被释放
  release(&p1->lock); // 这里释放了p1的锁
}
```

**解决方案**：保持选中进程的锁
```c
// 修复后代码
struct proc* find_highest_priority_process(void) {
  struct proc *p, *highest = 0;
  
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    
    if(p->state == RUNNABLE) {
      if(highest == 0 || p->priority < highest->priority) {
        if(highest != 0)
          release(&highest->lock); // 释放之前highest的锁
        highest = p;
        // 保持highest的锁，不释放
      } else {
        release(&p->lock);
      }
    } else {
      release(&p->lock);
    }
  }
  
  return highest; // 返回时仍然持有锁
}
```

### 7.5.4 统计信息不更新问题

**问题**：test_sched程序显示所有统计信息为0

**原因分析**：
1. 进程运行时间太短，统计没有足够时间累积
2. 时钟中断频率可能不够高
3. 统计更新逻辑可能有误

**解决方案**：
1. 修改测试程序，增加进程运行时间
2. 验证updatestatistics()调用频率
3. 添加调试输出验证统计更新

```c
// 改进的测试程序
int main() {
  pid = fork();
  if(pid == 0) {
    // 子进程：增加运行时间
    for(int i = 0; i < 1000000; i++) { /* 计算 */ }
    sleep(10); // 睡眠让统计有时间累积
    exit(0);
  } else {
    wait2(&retime, &rutime, &stime);
    printf("Stats: ready=%d, running=%d, sleeping=%d\n", 
           retime, rutime, stime);
  }
}
```

## 7.6 性能对比分析

### 7.6.1 测试环境配置
- **硬件**：QEMU模拟的RISC-V 64位处理器
- **内存**：128MB
- **CPU核心**：3个
- **测试工具**：自定义测试套件

### 7.6.2 性能指标定义
1. **响应时间**：从进程就绪到开始运行的时间
2. **吞吐量**：单位时间内完成的进程数
3. **公平性**：CPU时间分配的公平程度
4. **开销**：调度决策的时间开销

### 7.6.3 各算法性能对比

#### 响应时间对比
| 算法 | 最佳情况 | 最差情况 | 平均情况 |
|------|----------|----------|----------|
| DEFAULT | 中等 | 中等 | 中等 |
| PRIORITY | 很好（高优先级） | 很差（低优先级） | 中等 |
| FCFS | 好（第一个进程） | 很差（最后一个进程） | 差 |
| LOTTERY | 中等 | 中等 | 中等 |
| SML | 好（交互式进程） | 中等（CPU密集型） | 好 |

#### 吞吐量对比
| 算法 | CPU密集型 | I/O密集型 | 混合负载 |
|------|-----------|-----------|----------|
| DEFAULT | 中等 | 中等 | 中等 |
| PRIORITY | 中等 | 中等 | 中等 |
| FCFS | 中等 | 差 | 中等 |
| LOTTERY | 中等 | 中等 | 中等 |
| SML | 好 | 很好 | 好 |

#### 公平性对比
| 算法 | 公平性 | 说明 |
|------|--------|------|
| DEFAULT | 好 | 所有进程平等对待 |
| PRIORITY | 差 | 低优先级进程可能饥饿 |
| FCFS | 中等 | 先来先服务，但长进程影响短进程 |
| LOTTERY | 很好 | 彩票数比例对应CPU时间比例 |
| SML | 好 | 防止任何进程独占CPU |

### 7.6.4 实际测试结果

#### 测试用例1：混合负载
```bash
# 运行测试
$ make qemu SCHEDFLAG=PRIORITY
$ test_mixed_load

# 结果示例
Algorithm: PRIORITY
Total processes: 10
High priority completion: 100%
Low priority completion: 60%
Average response time: 15 ticks
```

#### 测试用例2：交互式负载
```bash
# 运行测试  
$ make qemu SCHEDFLAG=SML
$ test_interactive

# 结果示例
Algorithm: SML
Interactive processes: 5
Batch processes: 5
Interactive avg response: 8 ticks
Batch avg response: 25 ticks
```



